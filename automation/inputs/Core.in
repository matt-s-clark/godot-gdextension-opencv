void 	cv::absdiff (InputArray src1, InputArray src2, OutputArray dst)
void 	cv::add (InputArray src1, InputArray src2, OutputArray dst, InputArray mask=noArray(), int dtype=-1)
void 	cv::addWeighted (InputArray src1, double alpha, InputArray src2, double beta, double gamma, OutputArray dst, int dtype=-1)
void 	cv::batchDistance (InputArray src1, InputArray src2, OutputArray dist, int dtype, OutputArray nidx, int normType=NORM_L2, int K=0, InputArray mask=noArray(), int update=0, bool crosscheck=false)
void 	cv::bitwise_and (InputArray src1, InputArray src2, OutputArray dst, InputArray mask=noArray())
void 	cv::bitwise_not (InputArray src, OutputArray dst, InputArray mask=noArray())
void 	cv::bitwise_or (InputArray src1, InputArray src2, OutputArray dst, InputArray mask=noArray())
void 	cv::bitwise_xor (InputArray src1, InputArray src2, OutputArray dst, InputArray mask=noArray())
int 	cv::borderInterpolate (int p, int len, int borderType)
#void 	cv::broadcast (InputArray src, InputArray shape, OutputArray dst)
#void 	cv::calcCovarMatrix (const Mat *samples, int nsamples, Mat &covar, Mat &mean, int flags, int ctype=CV_64F)
void 	cv::calcCovarMatrix (InputArray samples, OutputArray covar, InputOutputArray mean, int flags, int ctype=CV_64F)
void 	cv::cartToPolar (InputArray x, InputArray y, OutputArray magnitude, OutputArray angle, bool angleInDegrees=false)
#bool 	cv::checkRange (InputArray a, bool quiet=true, Point *pos=0, double minVal=-DBL_MAX, double maxVal=DBL_MAX)
void 	cv::compare (InputArray src1, InputArray src2, OutputArray dst, int cmpop)
void 	cv::completeSymm (InputOutputArray m, bool lowerToUpper=false)
void 	cv::convertFp16 (InputArray src, OutputArray dst)
void 	cv::convertScaleAbs (InputArray src, OutputArray dst, double alpha=1, double beta=0)
#void 	cv::copyMakeBorder (InputArray src, OutputArray dst, int top, int bottom, int left, int right, int borderType, const Scalar &value=Scalar())
void 	cv::copyTo (InputArray src, OutputArray dst, InputArray mask)
int 	cv::countNonZero (InputArray src)
void 	cv::dct (InputArray src, OutputArray dst, int flags=0)
double 	cv::determinant (InputArray mtx)
void 	cv::dft (InputArray src, OutputArray dst, int flags=0, int nonzeroRows=0)
#void 	cv::divide (double scale, InputArray src2, OutputArray dst, int dtype=-1)
void 	cv::divide (InputArray src1, InputArray src2, OutputArray dst, double scale=1, int dtype=-1)
bool 	cv::eigen (InputArray src, OutputArray eigenvalues, OutputArray eigenvectors=noArray())
void 	cv::eigenNonSymmetric (InputArray src, OutputArray eigenvalues, OutputArray eigenvectors)
void 	cv::exp (InputArray src, OutputArray dst)
void 	cv::extractChannel (InputArray src, OutputArray dst, int coi)
void 	cv::findNonZero (InputArray src, OutputArray idx)
void 	cv::flip (InputArray src, OutputArray dst, int flipCode)
#void 	cv::flipND (InputArray src, OutputArray dst, int axis)
void 	cv::gemm (InputArray src1, InputArray src2, double alpha, InputArray src3, double beta, OutputArray dst, int flags=0)
int 	cv::getOptimalDFTSize (int vecsize)
#bool 	cv::hasNonZero (InputArray src)
#void 	cv::hconcat (const Mat *src, size_t nsrc, OutputArray dst)
void 	cv::hconcat (InputArray src1, InputArray src2, OutputArray dst)
#void 	cv::hconcat (InputArrayOfArrays src, OutputArray dst)
void 	cv::idct (InputArray src, OutputArray dst, int flags=0)
void 	cv::idft (InputArray src, OutputArray dst, int flags=0, int nonzeroRows=0)
void 	cv::inRange (InputArray src, InputArray lowerb, InputArray upperb, OutputArray dst)
void 	cv::insertChannel (InputArray src, InputOutputArray dst, int coi)
double 	cv::invert (InputArray src, OutputArray dst, int flags=DECOMP_LU)
void 	cv::log (InputArray src, OutputArray dst)
void 	cv::LUT (InputArray src, InputArray lut, OutputArray dst)
void 	cv::magnitude (InputArray x, InputArray y, OutputArray magnitude)
double 	cv::Mahalanobis (InputArray v1, InputArray v2, InputArray icovar)
#void 	cv::max (const Mat &src1, const Mat &src2, Mat &dst)
#void 	cv::max (const UMat &src1, const UMat &src2, UMat &dst)
void 	cv::max (InputArray src1, InputArray src2, OutputArray dst)
Scalar 	cv::mean (InputArray src, InputArray mask=noArray())
void 	cv::meanStdDev (InputArray src, OutputArray mean, OutputArray stddev, InputArray mask=noArray())
#void 	cv::merge (const Mat *mv, size_t count, OutputArray dst)
#void 	cv::merge (InputArrayOfArrays mv, OutputArray dst)
#void 	cv::min (const Mat &src1, const Mat &src2, Mat &dst)
#void 	cv::min (const UMat &src1, const UMat &src2, UMat &dst)
void 	cv::min (InputArray src1, InputArray src2, OutputArray dst)
#void 	cv::minMaxIdx (InputArray src, double *minVal, double *maxVal=0, int *minIdx=0, int *maxIdx=0, InputArray mask=noArray())
#void 	cv::minMaxLoc (const SparseMat &a, double *minVal, double *maxVal, int *minIdx=0, int *maxIdx=0)
#void 	cv::minMaxLoc (InputArray src, double *minVal, double *maxVal=0, Point *minLoc=0, Point *maxLoc=0, InputArray mask=noArray())
#void 	cv::mixChannels (const Mat *src, size_t nsrcs, Mat *dst, size_t ndsts, const int *fromTo, size_t npairs)
#void 	cv::mixChannels (InputArrayOfArrays src, InputOutputArrayOfArrays dst, const int *fromTo, size_t npairs)
#void 	cv::mixChannels (InputArrayOfArrays src, InputOutputArrayOfArrays dst, const std::vector< int > &fromTo)
void 	cv::mulSpectrums (InputArray a, InputArray b, OutputArray c, int flags, bool conjB=false)
void 	cv::multiply (InputArray src1, InputArray src2, OutputArray dst, double scale=1, int dtype=-1)
void 	cv::mulTransposed (InputArray src, OutputArray dst, bool aTa, InputArray delta=noArray(), double scale=1, int dtype=-1)
#double 	cv::norm (const SparseMat &src, int normType)
#double 	cv::norm (InputArray src1, InputArray src2, int normType=NORM_L2, InputArray mask=noArray())
double 	cv::norm (InputArray src1, int normType=NORM_L2, InputArray mask=noArray())
#void 	cv::normalize (const SparseMat &src, SparseMat &dst, double alpha, int normType)
void 	cv::normalize (InputArray src, InputOutputArray dst, double alpha=1, double beta=0, int norm_type=NORM_L2, int dtype=-1, InputArray mask=noArray())
void 	cv::patchNaNs (InputOutputArray a, double val=0)
void 	cv::PCABackProject (InputArray data, InputArray mean, InputArray eigenvectors, OutputArray result)
void 	cv::PCACompute (InputArray data, InputOutputArray mean, OutputArray eigenvectors, double retainedVariance)
#void 	cv::PCACompute (InputArray data, InputOutputArray mean, OutputArray eigenvectors, int maxComponents=0)
#void 	cv::PCACompute (InputArray data, InputOutputArray mean, OutputArray eigenvectors, OutputArray eigenvalues, double retainedVariance)
#void 	cv::PCACompute (InputArray data, InputOutputArray mean, OutputArray eigenvectors, OutputArray eigenvalues, int maxComponents=0)
void 	cv::PCAProject (InputArray data, InputArray mean, InputArray eigenvectors, OutputArray result)
void 	cv::perspectiveTransform (InputArray src, OutputArray dst, InputArray m)
void 	cv::phase (InputArray x, InputArray y, OutputArray angle, bool angleInDegrees=false)
void 	cv::polarToCart (InputArray magnitude, InputArray angle, OutputArray x, OutputArray y, bool angleInDegrees=false)
void 	cv::pow (InputArray src, double power, OutputArray dst)
double 	cv::PSNR (InputArray src1, InputArray src2, double R=255.)
void 	cv::randn (InputOutputArray dst, InputArray mean, InputArray stddev)
#void 	cv::randShuffle (InputOutputArray dst, double iterFactor=1., RNG *rng=0)
void 	cv::randu (InputOutputArray dst, InputArray low, InputArray high)
void 	cv::reduce (InputArray src, OutputArray dst, int dim, int rtype, int dtype=-1)
#NotFound void 	cv::reduceArgMax (InputArray src, OutputArray dst, int axis, bool lastIndex=false)
#NotFound void 	cv::reduceArgMin (InputArray src, OutputArray dst, int axis, bool lastIndex=false)
void 	cv::repeat (InputArray src, int ny, int nx, OutputArray dst)
void 	cv::rotate (InputArray src, OutputArray dst, int rotateCode)
void 	cv::scaleAdd (InputArray src1, double alpha, InputArray src2, OutputArray dst)
void 	cv::setIdentity (InputOutputArray mtx, const Scalar &s=Scalar(1))
void 	cv::setRNGSeed (int seed)
bool 	cv::solve (InputArray src1, InputArray src2, OutputArray dst, int flags=DECOMP_LU)
int 	cv::solveCubic (InputArray coeffs, OutputArray roots)
double 	cv::solvePoly (InputArray coeffs, OutputArray roots, int maxIters=300)
void 	cv::sort (InputArray src, OutputArray dst, int flags)
void 	cv::sortIdx (InputArray src, OutputArray dst, int flags)
#void 	cv::split (const Mat &src, Mat *mvbegin)
#Array void 	cv::split (InputArray m, OutputArrayOfArrays mv)
void 	cv::sqrt (InputArray src, OutputArray dst)
void 	cv::subtract (InputArray src1, InputArray src2, OutputArray dst, InputArray mask=noArray(), int dtype=-1)
Scalar 	cv::sum (InputArray src)
void 	cv::SVBackSubst (InputArray w, InputArray u, InputArray vt, InputArray rhs, OutputArray dst)
void 	cv::SVDecomp (InputArray src, OutputArray w, OutputArray u, OutputArray vt, int flags=0)
#RNG & 	cv::theRNG ()
Scalar 	cv::trace (InputArray mtx)
void 	cv::transform (InputArray src, OutputArray dst, InputArray m)
void 	cv::transpose (InputArray src, OutputArray dst)
#NotFound void 	cv::transposeND (InputArray src, const std::vector< int > &order, OutputArray dst)
#void 	cv::vconcat (const Mat *src, size_t nsrc, OutputArray dst)
void 	cv::vconcat (InputArray src1, InputArray src2, OutputArray dst)
#void 	cv::vconcat (InputArrayOfArrays src, OutputArray dst)